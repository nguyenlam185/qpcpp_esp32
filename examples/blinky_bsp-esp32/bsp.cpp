//$file${.::bsp.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: blinky_bsp-esp32.qm
// File:  ${.::bsp.cpp}
//
// This code has been generated by QM 7.0.1 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// Copyright (c) 2005 Quantum Leaps, LLC. All rights reserved.
//
//                 ____________________________________
//                /                                   /
//               /    GGGGGGG    PPPPPPPP   LL       /
//              /   GG     GG   PP     PP  LL       /
//             /   GG          PP     PP  LL       /
//            /   GG   GGGGG  PPPPPPPP   LL       /
//           /   GG      GG  PP         LL       /
//          /     GGGGGGG   PP         LLLLLLL  /
//         /___________________________________/
//
// SPDX-License-Identifier: GPL-3.0-or-later
//
// This generated code is open-source software licensed under the GNU
// General Public License (GPL) as published by the Free Software Foundation
// (see <https://www.gnu.org/licenses>).
//
// NOTE:
// The GPL does NOT permit the incorporation of this code into proprietary
// programs. Please contact Quantum Leaps for commercial licensing options,
// which expressly supersede the GPL and are designed explicitly for
// closed-source distribution.
//
// Quantum Leaps contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${.::bsp.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#include "qpcpp.hpp"   // QP-C++ framework
#include "blinky.hpp"  // Blinky application interface
#include "bsp.hpp"     // Board Support Package (BSP)
#include "Arduino.h"
#include "esp_freertos_hooks.h"

// If current ESP32 board does not define LED_BUILTIN
#ifndef LED_BUILTIN
#define LED_BUILTIN 2U
#endif

static void tickHook_ESP32(void); /*Tick hook for QP */
static uint8_t const l_TickHook = static_cast<uint8_t>(0);

static void tickHook_ESP32(void)
{
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    /* process time events for rate 0 */
    QP::QTimeEvt::TICK_FROM_ISR(&xHigherPriorityTaskWoken, &l_TickHook);
    /* notify FreeRTOS to perform context switch from ISR, if needed */
    if(xHigherPriorityTaskWoken) {
        portYIELD_FROM_ISR();
    }
}
//............................................................................
void QP::QF::onStartup(void) {
    esp_register_freertos_tick_hook_for_cpu(tickHook_ESP32, QP_CPU_NUM);
    QS_OBJ_DICTIONARY(&l_TickHook);
}
//............................................................................
extern "C" Q_NORETURN Q_onAssert(char const * const module, int location) {
    //
    // NOTE: add here your application-specific error handling
    //
    (void)module;
    (void)location;
    Serial.print("QP Assert module: ");
    Serial.print(module);
    Serial.print("@ ");
    Serial.println(location);
    QF_INT_DISABLE(); // disable all interrupts
    for (;;) { // sit in an endless loop for now
    }
}
//............................................................................
namespace BSP {
void init(void) {
    // initialize the hardware used in this sketch...
    // NOTE: interrupts are configured and started later in QF::onStartup()
    pinMode(LED_BUILTIN, OUTPUT);
    Serial.begin(115200); // run serial port at 115200 baud rate
    QS_INIT(nullptr);
}
//............................................................................
void ledOff(void) {
    digitalWrite(LED_BUILTIN, LOW);
    Serial.println("led off");
}
//............................................................................
void ledOn(void) {
    digitalWrite(LED_BUILTIN, HIGH);
    Serial.println("led on");
}
} // namespace BSP
